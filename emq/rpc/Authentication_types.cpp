/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Authentication_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace rpc { namespace auth {

int _kUserTypeValues[] = {
  UserType::DEV_XIAOMI_SSO,
  UserType::DEV_XIAOMI,
  UserType::APP_SECRET,
  UserType::APP_ACCESS_TOKEN,
  UserType::APP_XIAOMI_SSO,
  UserType::APP_ANONYMOUS
};
const char* _kUserTypeNames[] = {
  "DEV_XIAOMI_SSO",
  "DEV_XIAOMI",
  "APP_SECRET",
  "APP_ACCESS_TOKEN",
  "APP_XIAOMI_SSO",
  "APP_ANONYMOUS"
};
const std::map<int, const char*> _UserType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kUserTypeValues, _kUserTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMacAlgorithmValues[] = {
  MacAlgorithm::HmacMD5,
  MacAlgorithm::HmacSHA1,
  MacAlgorithm::HmacSHA256
};
const char* _kMacAlgorithmNames[] = {
  "HmacMD5",
  "HmacSHA1",
  "HmacSHA256"
};
const std::map<int, const char*> _MacAlgorithm_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kMacAlgorithmValues, _kMacAlgorithmNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kAppUserAuthProviderValues[] = {
  AppUserAuthProvider::XIAOMI_SSO,
  AppUserAuthProvider::XIAOMI_OAUTH,
  AppUserAuthProvider::QQ_OAUTH,
  AppUserAuthProvider::SINA_OAUTH,
  AppUserAuthProvider::RENREN_OAUTH
};
const char* _kAppUserAuthProviderNames[] = {
  "XIAOMI_SSO",
  "XIAOMI_OAUTH",
  "QQ_OAUTH",
  "SINA_OAUTH",
  "RENREN_OAUTH"
};
const std::map<int, const char*> _AppUserAuthProvider_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kAppUserAuthProviderValues, _kAppUserAuthProviderNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Credential::~Credential() throw() {
}


void Credential::__set_type(const UserType::type val) {
  this->type = val;
__isset.type = true;
}

void Credential::__set_secretKeyId(const std::string& val) {
  this->secretKeyId = val;
__isset.secretKeyId = true;
}

void Credential::__set_secretKey(const std::string& val) {
  this->secretKey = val;
__isset.secretKey = true;
}

const char* Credential::ascii_fingerprint = "E0E648A58FAB5424ACA7EFF4EAB40FE0";
const uint8_t Credential::binary_fingerprint[16] = {0xE0,0xE6,0x48,0xA5,0x8F,0xAB,0x54,0x24,0xAC,0xA7,0xEF,0xF4,0xEA,0xB4,0x0F,0xE0};

uint32_t Credential::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (UserType::type)ecast0;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->secretKeyId);
          this->__isset.secretKeyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->secretKey);
          this->__isset.secretKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Credential::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Credential");

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.secretKeyId) {
    xfer += oprot->writeFieldBegin("secretKeyId", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->secretKeyId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.secretKey) {
    xfer += oprot->writeFieldBegin("secretKey", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->secretKey);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Credential &a, Credential &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.secretKeyId, b.secretKeyId);
  swap(a.secretKey, b.secretKey);
  swap(a.__isset, b.__isset);
}

Credential::Credential(const Credential& other1) {
  type = other1.type;
  secretKeyId = other1.secretKeyId;
  secretKey = other1.secretKey;
  __isset = other1.__isset;
}
Credential& Credential::operator=(const Credential& other2) {
  type = other2.type;
  secretKeyId = other2.secretKeyId;
  secretKey = other2.secretKey;
  __isset = other2.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Credential& obj) {
  using apache::thrift::to_string;
  out << "Credential(";
  out << "type="; (obj.__isset.type ? (out << to_string(obj.type)) : (out << "<null>"));
  out << ", " << "secretKeyId="; (obj.__isset.secretKeyId ? (out << to_string(obj.secretKeyId)) : (out << "<null>"));
  out << ", " << "secretKey="; (obj.__isset.secretKey ? (out << to_string(obj.secretKey)) : (out << "<null>"));
  out << ")";
  return out;
}


HttpAuthorizationHeader::~HttpAuthorizationHeader() throw() {
}


void HttpAuthorizationHeader::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void HttpAuthorizationHeader::__set_userType(const UserType::type val) {
  this->userType = val;
__isset.userType = true;
}

void HttpAuthorizationHeader::__set_secretKeyId(const std::string& val) {
  this->secretKeyId = val;
__isset.secretKeyId = true;
}

void HttpAuthorizationHeader::__set_secretKey(const std::string& val) {
  this->secretKey = val;
__isset.secretKey = true;
}

void HttpAuthorizationHeader::__set_signature(const std::string& val) {
  this->signature = val;
__isset.signature = true;
}

void HttpAuthorizationHeader::__set_algorithm(const MacAlgorithm::type val) {
  this->algorithm = val;
__isset.algorithm = true;
}

void HttpAuthorizationHeader::__set_signedHeaders(const std::vector<std::string> & val) {
  this->signedHeaders = val;
__isset.signedHeaders = true;
}

void HttpAuthorizationHeader::__set_supportAccountKey(const bool val) {
  this->supportAccountKey = val;
__isset.supportAccountKey = true;
}

const char* HttpAuthorizationHeader::ascii_fingerprint = "BD141D421ADBD718188028B7D9557DBD";
const uint8_t HttpAuthorizationHeader::binary_fingerprint[16] = {0xBD,0x14,0x1D,0x42,0x1A,0xDB,0xD7,0x18,0x18,0x80,0x28,0xB7,0xD9,0x55,0x7D,0xBD};

uint32_t HttpAuthorizationHeader::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->userType = (UserType::type)ecast3;
          this->__isset.userType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->secretKeyId);
          this->__isset.secretKeyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->secretKey);
          this->__isset.secretKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->algorithm = (MacAlgorithm::type)ecast4;
          this->__isset.algorithm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->signedHeaders.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->signedHeaders.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readString(this->signedHeaders[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.signedHeaders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->supportAccountKey);
          this->__isset.supportAccountKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HttpAuthorizationHeader::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("HttpAuthorizationHeader");

  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.userType) {
    xfer += oprot->writeFieldBegin("userType", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->userType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.secretKeyId) {
    xfer += oprot->writeFieldBegin("secretKeyId", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->secretKeyId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.secretKey) {
    xfer += oprot->writeFieldBegin("secretKey", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->secretKey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.signature) {
    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->signature);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.algorithm) {
    xfer += oprot->writeFieldBegin("algorithm", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->algorithm);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.signedHeaders) {
    xfer += oprot->writeFieldBegin("signedHeaders", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->signedHeaders.size()));
      std::vector<std::string> ::const_iterator _iter10;
      for (_iter10 = this->signedHeaders.begin(); _iter10 != this->signedHeaders.end(); ++_iter10)
      {
        xfer += oprot->writeString((*_iter10));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.supportAccountKey) {
    xfer += oprot->writeFieldBegin("supportAccountKey", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->supportAccountKey);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(HttpAuthorizationHeader &a, HttpAuthorizationHeader &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.userType, b.userType);
  swap(a.secretKeyId, b.secretKeyId);
  swap(a.secretKey, b.secretKey);
  swap(a.signature, b.signature);
  swap(a.algorithm, b.algorithm);
  swap(a.signedHeaders, b.signedHeaders);
  swap(a.supportAccountKey, b.supportAccountKey);
  swap(a.__isset, b.__isset);
}

HttpAuthorizationHeader::HttpAuthorizationHeader(const HttpAuthorizationHeader& other11) {
  version = other11.version;
  userType = other11.userType;
  secretKeyId = other11.secretKeyId;
  secretKey = other11.secretKey;
  signature = other11.signature;
  algorithm = other11.algorithm;
  signedHeaders = other11.signedHeaders;
  supportAccountKey = other11.supportAccountKey;
  __isset = other11.__isset;
}
HttpAuthorizationHeader& HttpAuthorizationHeader::operator=(const HttpAuthorizationHeader& other12) {
  version = other12.version;
  userType = other12.userType;
  secretKeyId = other12.secretKeyId;
  secretKey = other12.secretKey;
  signature = other12.signature;
  algorithm = other12.algorithm;
  signedHeaders = other12.signedHeaders;
  supportAccountKey = other12.supportAccountKey;
  __isset = other12.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const HttpAuthorizationHeader& obj) {
  using apache::thrift::to_string;
  out << "HttpAuthorizationHeader(";
  out << "version="; (obj.__isset.version ? (out << to_string(obj.version)) : (out << "<null>"));
  out << ", " << "userType="; (obj.__isset.userType ? (out << to_string(obj.userType)) : (out << "<null>"));
  out << ", " << "secretKeyId="; (obj.__isset.secretKeyId ? (out << to_string(obj.secretKeyId)) : (out << "<null>"));
  out << ", " << "secretKey="; (obj.__isset.secretKey ? (out << to_string(obj.secretKey)) : (out << "<null>"));
  out << ", " << "signature="; (obj.__isset.signature ? (out << to_string(obj.signature)) : (out << "<null>"));
  out << ", " << "algorithm="; (obj.__isset.algorithm ? (out << to_string(obj.algorithm)) : (out << "<null>"));
  out << ", " << "signedHeaders="; (obj.__isset.signedHeaders ? (out << to_string(obj.signedHeaders)) : (out << "<null>"));
  out << ", " << "supportAccountKey="; (obj.__isset.supportAccountKey ? (out << to_string(obj.supportAccountKey)) : (out << "<null>"));
  out << ")";
  return out;
}

}} // namespace
